package vmnet

import (
	"fmt"
	"net"
	"os"
	"strconv"

	"github.com/miekg/dns"
	"golang.org/x/exp/slog"
	"gvisor.dev/gvisor/pkg/tcpip"
	"gvisor.dev/gvisor/pkg/tcpip/adapters/gonet"
	"gvisor.dev/gvisor/pkg/tcpip/header"
	"gvisor.dev/gvisor/pkg/tcpip/network/ipv4"
	"gvisor.dev/gvisor/pkg/tcpip/stack"
	"gvisor.dev/gvisor/pkg/tcpip/transport/tcp"
)

type gatewayOpts struct {
	MTU                  uint32
	PcapFile             *os.File
	MACAddress           net.HardwareAddr
	DNSConfig            *DNSConfig
	TCPMaxInFlight       int
	TCPReceiveBufferSize int
	Logger               *slog.Logger
}

func (o *gatewayOpts) dnsConfigTidy(gatewayIP net.IP) error {
	config, err := parseResolvConfFile(resolvConfPath)
	if err != nil {
		return err
	}
	if o.DNSConfig == nil {
		o.DNSConfig = config
	}
	if len(o.DNSConfig.Nameservers) == 0 {
		o.DNSConfig.Nameservers = config.Nameservers
	}

	if len(o.DNSConfig.SearchDomains) == 0 {
		o.DNSConfig.SearchDomains = config.SearchDomains
	}
	// overwrite to use fqdn format in keys.
	for mayfqdn, addr := range o.DNSConfig.StaticRecords {
		delete(o.DNSConfig.StaticRecords, mayfqdn)
		o.DNSConfig.StaticRecords[dns.Fqdn(mayfqdn)] = addr
	}
	return nil
}

// GatewayOpts is functional options.
type GatewayOpts func(*gatewayOpts)

// WithMTU is an option to set MTU (maximum transmission unit) between the gateway
// and some link devices.
//
// Default is 1500.
func WithMTU(mtu uint32) GatewayOpts {
	return func(g *gatewayOpts) {
		g.MTU = mtu
	}
}

// WithPcapFile is an option to create a pcap file based on the given file
// for writing packet data.
//
// Default is nil.
func WithPcapFile(pcapFile *os.File) GatewayOpts {
	return func(g *gatewayOpts) {
		g.PcapFile = pcapFile
	}
}

// WithMACAddress is an option to specify the gateway MAC address.
//
// Default is "7a:5b:10:21:90:e3"
func WithMACAddress(hwAddr net.HardwareAddr) GatewayOpts {
	return func(g *gatewayOpts) {
		g.MACAddress = hwAddr
	}
}

// WithDNSConfig is an option to configure DNS.
//
// Default value will be created from your /etc/resolv.conf file.
func WithDNSConfig(dnsConfig *DNSConfig) GatewayOpts {
	return func(g *gatewayOpts) {
		g.DNSConfig = dnsConfig
	}
}

// WithTCPMaxInFlight is an option initializes a new TCP forwarder with the given
// maximum number of in-flight connection attempts. Once the maximum is reached
// new incoming connection requests will be ignored.
//
// Default is 512.
func WithTCPMaxInFlight(maxInFlight int) GatewayOpts {
	return func(g *gatewayOpts) {
		g.TCPMaxInFlight = maxInFlight
	}
}

// WithTCPReceiveBufferSize is an option when use initialize a new TCP forwarder with
// the given buffer size of TCP Recieve window.
//
// Default is 1048576.
func WithTCPReceiveBufferSize(rcvWnd int) GatewayOpts {
	return func(g *gatewayOpts) {
		g.TCPReceiveBufferSize = rcvWnd
	}
}

// WithLogger is an option for debug logging which is using the given logger.
//
// Default is nil.
func WithLogger(logger *slog.Logger) GatewayOpts {
	return func(g *gatewayOpts) {
		g.Logger = logger
	}
}

// Gateway is a gateway.
type Gateway struct {
	subnet               tcpip.Subnet
	hwAddress            net.HardwareAddr
	ipv4                 net.IP // IPv4
	leases               *leaseDB
	dev                  *os.File
	stack                *stack.Stack
	endpoint             *endpoint
	pool                 *bytePool
	dnsConfig            *DNSConfig
	tcpMaxInFlight       int
	tcpReceiveBufferSize int
	logger               *slog.Logger
}

// NewGateway initializes a new gateway and a new network stack that contains it.
func NewGateway(cidr string, opts ...GatewayOpts) (*Gateway, error) {
	opt := &gatewayOpts{
		MTU: 1500,
		// "7a:5b:10:21:90:e3"
		// generated by https://go.dev/play/p/9XRn_wtY2go
		MACAddress: net.HardwareAddr{
			0x7a, 0x5b, 0x10, 0x21, 0x90, 0xe3,
		},
		TCPMaxInFlight:       512,
		TCPReceiveBufferSize: tcp.DefaultReceiveBufferSize,
		Logger:               slog.New(&nopHandler{}), // no output
	}
	for _, optFunc := range opts {
		optFunc(opt)
	}

	_, parsedSubnet, err := net.ParseCIDR(cidr)
	if err != nil {
		return nil, err
	}

	db, err := newLeaseDB(cidr)
	if err != nil {
		return nil, err
	}
	gatewayIP, err := db.LeaseIP(opt.MACAddress)
	if err != nil {
		return nil, err
	}

	subnet, err := tcpip.NewSubnet(
		tcpip.Address(parsedSubnet.IP),
		tcpip.AddressMask(parsedSubnet.Mask),
	)
	if err != nil {
		return nil, err
	}

	if err := opt.dnsConfigTidy(gatewayIP); err != nil {
		return nil, err
	}

	pool := newBytePool(int(opt.MTU))

	ep, err := newGatewayEndpoint(gatewayEndpointOption{
		MTU:     opt.MTU,
		Address: tcpip.LinkAddress(opt.MACAddress),
		ClosedFunc: func(ipAddr tcpip.Address, err error) {
			opt.Logger.Error(
				"closed ehternet endpoint", err,
				slog.String("IP Address", ipAddr.String()),
			)
		},
		Writer: opt.PcapFile,
		Pool:   pool,
		Logger: opt.Logger,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create an default gateway endpoint: %w", err)
	}

	gatewayIPv4 := tcpip.Address(gatewayIP.To4())
	s, err := createGatewayNetworkStack(ep, gatewayIPv4, subnet)
	if err != nil {
		return nil, err
	}

	gw := &Gateway{
		subnet:               subnet,
		hwAddress:            opt.MACAddress,
		ipv4:                 gatewayIP,
		leases:               db,
		stack:                s,
		endpoint:             ep,
		pool:                 pool,
		dnsConfig:            opt.DNSConfig,
		tcpMaxInFlight:       opt.TCPMaxInFlight,
		tcpReceiveBufferSize: opt.TCPReceiveBufferSize,
		logger:               opt.Logger,
	}

	err = gw.serveDHCP4Server(&tcpip.FullAddress{
		NIC:  nicID,
		Port: 67,
	})
	if err != nil {
		return nil, err
	}

	err = gw.serveDNS4Server(&tcpip.FullAddress{
		NIC:  nicID,
		Addr: gatewayIPv4,
		Port: 53,
	})
	if err != nil {
		return nil, err
	}

	gw.setUDPForwarder()
	gw.setTCPForwarder()

	return gw, nil
}

// IPv4 returns IPv4 address.
func (gw *Gateway) IPv4() net.IP { return gw.ipv4.To4() }

// MACAddress returns MAC address.
func (gw *Gateway) MACAddress() net.HardwareAddr { return gw.hwAddress }

func createGatewayNetworkStack(ep stack.LinkEndpoint, gatewayIPv4 tcpip.Address, subnet tcpip.Subnet) (*stack.Stack, error) {
	s, err := createBaseNetStack()
	if err != nil {
		return nil, err
	}

	if err := s.CreateNIC(nicID, ep); err != nil {
		return nil, fmt.Errorf("could not create netstack NIC: %v", err)
	}

	if err := s.AddProtocolAddress(
		nicID,
		tcpip.ProtocolAddress{
			Protocol:          ipv4.ProtocolNumber,
			AddressWithPrefix: gatewayIPv4.WithPrefix(),
		},
		stack.AddressProperties{},
	); err != nil {
		return nil, fmt.Errorf(err.String())
	}

	s.SetRouteTable([]tcpip.Route{
		{
			Destination: header.IPv4EmptySubnet,
			// Gateway:     gatewayIPv4,
			NIC: nicID,
		},
	})

	// Enable to forward transport layer data.
	s.SetPromiscuousMode(nicID, true)

	return s, nil
}

// EthernetDevice is an ethernet device.
type EthernetDevice struct {
	dev       *os.File
	ipv4      net.IP
	closeFunc func()
	pool      *bytePool
	hwAddress net.HardwareAddr
}

type ethernetDeviceOpts struct {
	SendBufferSize     int
	TCPIncomingForward map[int]int
}

// EthernetDeviceOpts is a optional type for NewEthernetDevice.
type EthernetDeviceOpts func(*ethernetDeviceOpts)

// WithSendBufferSize is an option sets SO_SNDBUF size between
// ethernet device and guest system. And sets SO_RCVBUF size
// four times of SO_SNDBUF. the default SO_SNDBUF is 131072.
func WithSendBufferSize(bufSize int) EthernetDeviceOpts {
	return func(edo *ethernetDeviceOpts) {
		edo.SendBufferSize = bufSize
	}
}

// WithTCPIncomingForward is an option to set TCP forward from host machine to guest machine.
// For example, if you want to connect from the host machine to the guest machine via ssh,
// configure as follows:
//
// `WithTCPIncomingForward(8888, 22)` then you can ssh to the guest OS via 127.0.0.1:8888
//
// This option can be applied multiple times.
func WithTCPIncomingForward(hostPort, guestPort int) EthernetDeviceOpts {
	return func(edo *ethernetDeviceOpts) {
		if edo.TCPIncomingForward == nil {
			edo.TCPIncomingForward = make(map[int]int)
		}
		edo.TCPIncomingForward[hostPort] = guestPort
	}
}

// NewEthernetDevice creates a new ethernet device.
func (gw *Gateway) NewEthernetDevice(hwAddr net.HardwareAddr, opts ...EthernetDeviceOpts) (*EthernetDevice, error) {
	o := ethernetDeviceOpts{
		// net.inet.tcp.sendspace: 131072 (sysctl net.inet.tcp.sendspace)
		SendBufferSize: 128 * 1024,
	}
	for _, optFunc := range opts {
		optFunc(&o)
	}

	deviceIPv4, err := gw.leases.LeaseIP(hwAddr)
	if err != nil {
		return nil, err
	}
	dev, network, err := socketPair(o.SendBufferSize, o.SendBufferSize)
	if err != nil {
		return nil, fmt.Errorf("failed to create socket pair: %w", err)
	}
	closeIfErr := func() {
		dev.Close()
		network.Close()
	}

	ethConn, err := net.FileConn(network)
	if err != nil {
		closeIfErr()
		return nil, fmt.Errorf("failed to make a connection: %w", err)
	}
	closeIfErr2 := func() {
		closeIfErr()
		ethConn.Close()
	}

	deviceIPv4Addr := tcpip.Address(deviceIPv4.To4())
	gw.endpoint.RegisterConn(deviceIPv4Addr, ethConn)

	for hostPort, guestPort := range o.TCPIncomingForward {
		err := gw.tcpIncomingForward(deviceIPv4, guestPort, hostPort)
		if err != nil {
			return nil, fmt.Errorf(
				"failed to listen tcp forward proxy 127.0.0.1:%d <-> %s:%d: %w",
				hostPort,
				deviceIPv4.String(), guestPort,
				err,
			)
		}
	}

	return &EthernetDevice{
		dev:       dev,
		ipv4:      deviceIPv4,
		closeFunc: closeIfErr2,
		pool:      gw.pool,
		hwAddress: hwAddr,
	}, nil
}

// File returns *os.File for this device.
func (dev *EthernetDevice) File() *os.File { return dev.dev }

// IPv4 returns ipv4 address that you can use in the guest OS.
func (dev *EthernetDevice) IPv4() net.IP { return dev.ipv4 }

// MACAddress returns MAC address.
func (dev *EthernetDevice) MACAddress() net.HardwareAddr { return dev.hwAddress }

// Close closes this device and ethernet connection.
func (dev *EthernetDevice) Close() error { dev.closeFunc(); return nil }

func (gw *Gateway) tcpIncomingForward(guestIPv4 net.IP, guestPort, hostPort int) error {
	ln, err := net.Listen("tcp", "127.0.0.1:"+strconv.Itoa(hostPort))
	if err != nil {
		return err
	}

	proxy := fmt.Sprintf(
		"127.0.0.1:%d <-> %s:%d",
		hostPort,
		guestIPv4.String(), guestPort,
	)

	go func() {
		defer ln.Close()

		for {
			conn, err := ln.Accept()
			if err != nil {
				gw.logger.Error(
					"failed to accept connection in incoming TCP forward", err,
					slog.String("forward", proxy),
				)
				return
			}

			go func() {
				defer conn.Close()

				conn1, err := gonet.DialTCP(gw.stack, tcpip.FullAddress{
					NIC:  nicID,
					Addr: tcpip.Address(guestIPv4),
					Port: uint16(guestPort),
				}, ipv4.ProtocolNumber)
				if err != nil {
					gw.logger.Error(
						"failed to dial connection to upstream in incoming TCP forward", err,
						slog.String("forward", proxy),
					)
					return
				}
				defer conn1.Close()

				if err := gw.pool.tcpRelay(conn, conn1); err != nil {
					gw.logger.Error(
						"failed to relay the connection in incoming TCP forward", err,
						slog.String("forward", proxy),
					)
				}
			}()
		}
	}()

	return nil
}
