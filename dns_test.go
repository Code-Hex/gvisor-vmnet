package vmnet

import (
	"net/netip"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/miekg/dns"
)

func TestParseResolvConf(t *testing.T) {
	cases := []struct {
		in      string
		want    *DNSConfig
		wantErr bool
	}{
		{
			in:   "# hello",
			want: &DNSConfig{},
		},
		{
			in: "nameserver 192.168.11.1",
			want: &DNSConfig{
				Nameservers: []netip.Addr{
					netip.MustParseAddr("192.168.11.1"),
				},
			},
		},
		{
			in: "nameserver 192.168.11.1 # hello",
			want: &DNSConfig{
				Nameservers: []netip.Addr{
					netip.MustParseAddr("192.168.11.1"),
				},
			},
		},
		{
			in:   "# nameserver 192.168.11.1",
			want: &DNSConfig{},
		},
		{
			in:      "nameserver hello",
			wantErr: true,
		},
		{
			in: "search vlan",
			want: &DNSConfig{
				SearchDomains: []string{"vlan."},
			},
		},
		{
			in:   "# search vlan",
			want: &DNSConfig{},
		},
	}
	for _, tc := range cases {
		got, err := parseResolvConf(strings.NewReader(tc.in))
		if tc.wantErr {
			if err != nil {
				continue
			}
			t.Errorf("missing error for %q", tc.in)
			continue
		}
		if diff := cmp.Diff(tc.want, got, cmp.Comparer(func(x, y netip.Addr) bool {
			return x.Compare(y) == 0
		})); diff != "" {
			t.Errorf("(-want, +got)\n%s", diff)
		}
	}

	t.Run("parse example", func(t *testing.T) {
		const example = `#
# macOS Notice
#
# This file is not consulted for DNS hostname resolution, address
# resolution, or the DNS query routing mechanism used by most
# processes on this system.
#
# To view the DNS configuration used by this system, use:
#   scutil --dns
#
# SEE ALSO
#   dns-sd(1), scutil(8)
#
# This file is automatically generated.
#
search vlan
nameserver 192.168.11.1
`
		got, err := parseResolvConf(strings.NewReader(example))
		if err != nil {
			t.Fatal(err)
		}
		want := &DNSConfig{
			Nameservers: []netip.Addr{
				netip.MustParseAddr("192.168.11.1"),
			},
			SearchDomains: []string{"vlan."},
		}
		if diff := cmp.Diff(want, got, cmp.Comparer(func(x, y netip.Addr) bool {
			return x.Compare(y) == 0
		})); diff != "" {
			t.Errorf("(-want, +got)\n%s", diff)
		}
	})
}

func Test_findDNSARecordMinTTL(t *testing.T) {
	tests := []struct {
		answers    []dns.RR
		wantMinTTL uint32
	}{
		{
			answers:    []dns.RR{},
			wantMinTTL: 0,
		},
		{
			answers: []dns.RR{
				&dns.A{Hdr: dns.RR_Header{Ttl: 400}},
				&dns.A{Hdr: dns.RR_Header{Ttl: 300}},
				&dns.A{Hdr: dns.RR_Header{Ttl: 500}},
			},
			wantMinTTL: 300,
		},
		{
			answers: []dns.RR{
				&dns.NS{Hdr: dns.RR_Header{Ttl: 100}}, // expected ignore
				&dns.A{Hdr: dns.RR_Header{Ttl: 300}},
				&dns.A{Hdr: dns.RR_Header{Ttl: 500}},
			},
			wantMinTTL: 300,
		},
	}
	for _, tt := range tests {
		if gotMinTTL := findDNSARecordMinTTL(tt.answers); gotMinTTL != tt.wantMinTTL {
			t.Errorf("findDNSARecordMinTTL() = %v, want %v", gotMinTTL, tt.wantMinTTL)
		}
	}
}
